# MCPアーキテクチャ

## 概要

このプロジェクトでは、タスク管理システムをMCP（Module Communication Protocol）を通じて操作できるようにしています。MCPは、異なるシステム間での通信を標準化するためのプロトコルで、このプロジェクトではHonoフレームワークを使用してREST APIとして実装しています。

## アーキテクチャ構造

```
src/
├── core/            # コアビジネスロジック
│   └── tasks.ts     # タスク操作のコア機能
├── mcp/             # MCPサーバー関連
│   ├── adapters/    # MCPアダプター
│   ├── controllers/ # コントローラー
│   ├── index.ts     # サーバーエントリーポイント
│   └── routes.ts    # ルート定義
├── types/           # 型定義
│   └── Task.ts      # タスク関連の型定義
└── utils/           # ユーティリティ
    └── task-utils.ts # タスク操作のユーティリティ関数
```

## レイヤー構造

1. **コアレイヤー** (`src/core/`):
   - ビジネスロジックを実装
   - タスクの作成、一覧取得、完了、削除、更新などの基本操作

2. **MCPレイヤー** (`src/mcp/`):
   - MCPプロトコルに準拠したAPIエンドポイントを提供
   - アダプターパターンを使用してコアロジックとMCPインターフェースを分離

3. **ユーティリティレイヤー** (`src/utils/`):
   - コアロジックをサポートする関数群
   - ファイル操作やタスクのパース処理など

## データフロー

1. クライアントがMCPエンドポイントにリクエストを送信
2. MCPサーバーがリクエストを受け取り、適切なアダプターを呼び出す
3. アダプターがリクエストパラメーターを変換し、コア機能を呼び出す
4. コア機能が実際のタスク操作を実行し、ユーティリティ関数を使用
5. 結果がアダプターに返され、適切なレスポンス形式に変換される
6. MCPサーバーがレスポンスをクライアントに返す

## 学び

MCPアーキテクチャは、システム間の通信を標準化することで、異なるクライアントが同じバックエンドサービスを簡単に利用できるようにします。この実装では特に以下の点に注意しました：

1. **責務の分離**: 各レイヤーが明確な責務を持つように設計
2. **型安全性**: TypeScriptの型システムを活用して、APIの入出力を明確に定義
3. **テスト容易性**: 各レイヤーを分離することで、ユニットテストが書きやすくなる

このアーキテクチャにより、将来的にシステムが拡張される際も、影響範囲を最小限に抑えることができます。 